/*
 * The editor is the main control structure for Sculptly. It runs the 3D scene
 * and maintains the render area. It also passes events through to the toolbox
 * and grants access to the scene.
 */
/**
 * @TODO: Remove quickstart section.
 */

var editor = {};
$(function(){
    // Set up the editor's private globals
    var _3 = THREE;
    var mouseProjector = new _3.Projector();
    var activeObject   = null;
    var activeMaterial = new _3.MeshBasicMaterial({
            color     : 0xFFFFFF,
            wireframe : true,
            shading   : _3.NoShading
        });
    var mouse = {};

    // Grab the viewport and its stats
    var viewport = $('div.viewport');
    var width = viewport.width();
    var height = viewport.height();

    // Set up THREE.js
    var renderer = new _3.WebGLRenderer({ clearColor : 0x4d4d59 });
    var camera = new _3.Camera( 45, width/height, 0.01, 10000 );
    var scene = new _3.Scene();

    camera.translateXYZ( 0, 50, 300, true );
    camera.lookAt( new _3.Vector3( 0, 0, 0 ) );
    renderer.setSize( width, height );

    viewport.append( renderer.domElement );

// --- BEGIN QUICKSTART SECTION --- //

    var sphereMat = new _3.MeshLambertMaterial({ color : 0xCC0000 });
    var sphere = new _3.Mesh( new _3.CubeGeometry( 50, 50, 50 ), sphereMat );
    scene.addChild( sphere );

    var pointLight = new _3.PointLight( 0xFFFFFF );
    pointLight.translateXYZ( 10, 50, 130, true );
    scene.addLight( pointLight );

    // Add the grid
    var gridMat = new _3.LineBasicMaterial({ color : 0xFFFFFF });
    var grid = new _3.Mesh( new _3.PlaneGeometry( 200, 200, 50, 50 ), gridMat );
    grid.rotateX( Math.PI / 2 );
    scene.addChild( grid );

// --- END QUICKSTART SECTION --- //

    // Add mouse picking
    viewport.delegate( 'canvas', 'click', function(e){
        e.preventDefault();

        // Project the mouse position into 3d space and cast the ray
        var mouse3dPos = projectMouse( e.offsetX, e.offsetY );
        var ray = new _3.Ray(
                mouse3dPos,
                mouse3dPos.clone().subSelf( camera.position ).normalize()
            );

        // Find the intersection and take the closest one
        var intersectedObjects = ray.intersectScene( scene );
        var closest = null;
        intersectedObjects.forEach( function( obj ){
            if( !closest || obj.distance < closest.distance )
                closest = obj;
        });

        // Do we currently have an active object? Clear its selected state
        if( activeObject )
            activeObject.materials.pop();

        // If we picked an object, set it as active.
        if( closest ){
            activeObject = closest.object;
            activeObject.materials.push( activeMaterial );
        }
        else
            activeObject = null;
    });

    // Add tracking for the mouse as well
    viewport.delegate(
            'canvas',
            'mouseenter mouseleave mousemove mousedown mouseup'
           +'keydown keyup keypress'
           +'click dblclick',
            function(e){
        // We want to pass all these events through to the tools.
        toolbox.trigger( $.Event( 'sculptly_'+e.type, e ) );
    }).delegate( 'canvas', 'mouseenter', function(e){
        e.preventDefault();
        mouse.entered = true;
    }).delegate( 'canvas', 'mouseleave', function(e){
        e.preventDefault();
        mouse = {};
    }).delegate( 'canvas', 'mousemove', function(e){
        e.preventDefault();
        if( mouse.x !== undefined && mouse.y !== undefined ){
            mouse.deltaX = e.offsetX - mouse.x;
            mouse.deltaY = e.offsetY - mouse.y;
        }
        mouse.x = e.offsetX;
        mouse.y = e.offsetY;
    }).delegate( 'canvas', 'mousedown', function(e){
        e.preventDefault();
        mouse.downX = e.offsetX;
        mouse.downY = e.offsetY;
        delete mouse.dragDeltaX;
        delete mouse.dragDeltaY;
        mouse.down  = true;
    }).delegate( 'canvas', 'mouseup', function(e){
        e.preventDefault();
        if( mouse.downX !== undefined && mouse.downY !== undefined ){
            mouse.dragDeltaX = e.offsetX - mouse.downX;
            mouse.dragDeltaY = e.offsetY - mouse.downY;
        }
        mouse.upX  = e.offsetX;
        mouse.upY  = e.offsetY;
        mouse.down = false;
    });

    // Start rendering.
    function render(){
        requestAnimFrame( render );

        toolbox.getActive().update();

        renderer.render( scene, camera );
    }

    /**
     * Projects a mouse position into 3d space.
     *
     * @param {Number} x The X coordinate.
     * @param {Number} y The Y coordinate.
     *
     * @return {THREE.Vector3} The projected position of the mouse.
     */
    function projectMouse( x, y ){
        var canvas = viewport.find( 'canvas' );
        var mouse2dPos = new _3.Vector3(
                (x / canvas.width()) * 2 - 1,
               -(y / canvas.height()) * 2 + 1, // invert Y coord
                1
            );
        return mouseProjector.unprojectVector( mouse2dPos, camera );
    }

    /**
     * Returns a copy of the current mouse state.
     *
     * @return {Object} 
     */
    function getMouse(){
        return $.extend( {}, mouse );
    }
    editor.getMouse = getMouse;

    render();
}); // end editor on ready


