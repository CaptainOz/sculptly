/// ## GetShader ##
/// Gets a vertex and fragment shader by name.
///
/// @param {String} name The name of the shader to retrieve.
///
/// @return {Object} An object with the keys 'fragment' and 'vertex' whose values
///                  are (respectively) the fragment and vertex shader scripts.

var m = {
    fs   : require( 'fs' ),
    path : require( 'path' ),
    api  : require( '../api' )
};
var SHADER_PATH = m.path.normalize( m.path.join( __dirname, '../shaders' ) );

function GetShader( params ){
    // Call parent constructor
    m.api.CommandRequest.call( this, 'GetShader', params );
}

// Inherit and export this command.
m.api.CommandRequest.inherit( GetShader );
module.exports = GetShader;

GetShader.prototype.start = function(){
    var self = this;
    try{
        // Clean the shader name and check that it exists.
        var name      = this.requireParam( 'name' );
        var cleanName = m.api.sanitize( name );
        var shaderDir = m.path.join( SHADER_PATH, cleanName );

        m.api.fileExists( shaderDir, function( exists ){
            if( !exists ){
                var err = self.error( m.api.RC.INVALID_PARAM, 'Shader "'+name+'" not found.' );
                self.emit( 'error', err );
                return;
            }

            // The container exists, but do the vertex and fragment scripts?
            var fragShader = m.path.join( shaderDir, 'fragment.shader' );
            var vertShader = m.path.join( shaderDir, 'vertex.shader' );
            m.api.fileExists( [ fragShader, vertShader ], function( exists ){
                // If either of the shaders don't exist something is fscked.
                // NOTE: This should NEVER happen.
                if( !exists ){
                    var err = self.serverError( 'Shader script missing' );
                    self.emit( 'error', err );
                    return;
                }
                respondWithShaders.call( self, fragShader, vertShader );
            });
        });
    }
    catch( e ){
        this.emit( 'error', e );
    }
};

// Reads the shaders, composes the JSON response, and sends it.
//
// @note
// This function should be called in the context of the CommandRequest object.
//
// @param {String} fragShaderPath The path to the fragment shader.
// @param {String} vertShaderPath The path to the vertex shader.
function respondWithShaders( fragShaderPath, vertShaderPath ){
    var self = this;
    readShaders.call( this, fragShaderPath, vertShaderPath, function( fragScript, vertScript ){
        var response = {
            code    : m.api.RC.SUCCESS,
            message : 'Success',
            data    : {
                fragment : fragScript.trim(),
                vertex   : vertScript.trim()
            }
        };

        self.emit( 'data', JSON.stringify( response ) );
        self.emit( 'end' );
    });
}

// Reads the shaders from disc.
//
// @note
// This function should be called in the context of the CommandRequest object.
//
// @param {String}   fragShaderPath The path to the fragment shader.
// @param {String}   vertShaderPath The path to the vertex shader.
// @param {Function} callback       The function to call with the contents.
function readShaders( fragShaderPath, vertShaderPath, callback ){
    // Set up variables
    var fragShaderScript;
    var vertShaderScript;
    var self = this;

    // Open the frag and vert shaders and then read them
    m.fs.readFile( fragShaderPath, 'utf8', function( readErr, data ){
        if( readErr ){
            var err = self.serverError( 'Failed to read fragment shader: '+readErr );
            self.emit( 'error', err );
            return;
        }

        // Save this data and see if the vertex shader already finished.
        fragShaderScript = data;
        if( vertShaderScript )
            callback( fragShaderScript, vertShaderScript );
    });
    m.fs.readFile( vertShaderPath, 'utf8', function( readErr, data ){
        if( readErr ){
            var err = self.serverError( 'Failed to read vertex shader: '+readErr );
            self.emit( 'error', err );
            return;
        }

        // Save this data and see if the fragment shader already finished.
        vertShaderScript = data;
        if( fragShaderScript )
            callback( fragShaderScript, vertShaderScript );
    });
}






